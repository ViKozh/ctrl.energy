substitutions:
  voltage_normal: '230'
  supported_load_level: '32'
  voltage_min_bound: '120'
  voltage_max_bound: '280'
  voltage_warning_lower_level: '170'
  voltage_warning_upper_level: '240'
  voltage_failure_lower_level: '150'
  voltage_failure_upper_level: '270'
  phase_shift_warning_level: '5.0'
  phase_shift_failure_level: '20.0'
  overload_warning_level: '5.0'
  overload_failure_level: '20.0'
  energy_source_name: !secret energy_provider
  tg_bot_token: !secret tg_token_id
  tg_chat_id: !secret tg_chat_id
  grafana_url: !secret grafana_url
  ha_url: !secret ha_url
  case_pincode: !secret pincode

esphome:
  name: energy-control
  comment: Energy Control
  project:
    name: "vks.control_energy"
    version: "1.0"
  libraries:
    - SPI
    - FS
    - SD
    - FFat
    - ArduinoJson
  includes:
    - csv_strings.h
    - tg_bot_strings.h
    - log_strings.h
    - sdcard.h
    - settings.h
    - problems.h
    - snapshot.h
  platformio_options:
    build_flags: -DFS_NO_GLOBALS
    lib_ldf_mode: deep+    
  on_boot:
    priority: 600
    then:
      - ds1307.read_time: rtc_clock
      - if:
          condition:
            - lambda: return id(disable_deep_sleep);
          then:
            - deep_sleep.prevent: dsleep
      - lambda: |-
          id(card_available) = SD.begin(5);

          if(!id(card_available)) {
            ESP_LOGW("SD", "Unable to mount SD card.");
          } else {
            sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Node is starting...");
          }

          settings::storage = &id(system_settings)[0];
          ESP_LOGD("Settings", "Loading settings...");
          if(!settings::readSettings()) {
            ESP_LOGE("Settings", "Unable to initialize settings data.");
          }
          

          auto counter = id(em_x_total_counter).state;
          if(counter != NAN) {
            for(int i = 0; i < sizeof(snapData.data); i++) {
              snapData.data[i] = id(snapshot_data)[i];
            };
            loadFromSnapshot(counter);
          };
          
          add_on_failure_callback([](Problems problem) { 
            id(process_problem).execute(
              static_cast<int>(problem),
              static_cast<int>(ProblemState::FAILURE)
              ); });
          add_on_warning_callback([](Problems problem) { 
            id(process_problem).execute(
              static_cast<int>(problem), 
              static_cast<int>(ProblemState::WARNING)
              ); });
          add_on_restore_callback([](Problems problem) { 
            id(process_problem).execute(
              static_cast<int>(problem),
              static_cast<int>(ProblemState::NONE)
              ); });

          if(!id(card_available)) {
            ESP_LOGW("SD", "Unable to mount SD card.");
          } else {
            sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Node has been started.");
          }
          id(is_loaded) = true;
  on_shutdown:
    priority: 400
    then:
      - lambda: |-
          if(!id(is_loaded)) {
            ESP_LOGE("Node", "Invalid system state. Shutdown is initialized before node has been loaded.");
            return;
          };

          if(!id(card_available)) {
            ESP_LOGW("SD", "Unable to mount SD card.");
            return;
          } else {
            sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Node will be shutted down (deep sleep or connectivity loss).");
            saveToSnapshot(id(em_x_total_counter).state);
            for(int i = 0; i < sizeof(snapData.data); i++) {
              id(snapshot_data)[i] = snapData.data[i];
            };
            ESP_LOGD("Settings", "Saving settings to SD Card...");
            if(!settings::writeSettings()) {
              ESP_LOGE("Settings", "Unable to save settings data.");
            }
          };
          sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Gracefully shut down.");


esp32:
  board: esp32dev
  framework:
    type: arduino
    version: 2.0.14
    platform_version: 6.5.0

logger:
  level: INFO

dallas:
  - pin: GPIO14
    id: case_temp

api:
  encryption:
    key: !secret enc_key
  reboot_timeout: 30s
  services:
    - service: csv_test
      variables:
        test_case: int
      then:
        - lambda: |-
            switch(test_case) {
              case 1:
                writeDailyLog(id(rtc_clock).utcnow());
                break;
              case 2:
                sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "TEST, test, TeSt");
                break;
              case 0:
              default:
                const char* sdpath_1 = "/test/1";
                const char* sdpath_2 = "/xs";
                if(!SD.exists(sdpath_1)) {
                  ESP_LOGW("SD", "Directory %s is not exist.", sdpath_1);
                  SD.mkdir(sdpath_1);
                  if(SD.exists(sdpath_1))
                    ESP_LOGW("SD", "Created %s", sdpath_1);
                } else {
                  ESP_LOGW("SD", "Directory %s is exist.", sdpath_1);
                }
                if(!SD.exists(sdpath_2)) {
                  ESP_LOGW("SD", "Directory %s is not exist.", sdpath_2);
                  SD.mkdir(sdpath_2);
                  if(SD.exists(sdpath_2))
                    ESP_LOGW("SD", "Created %s", sdpath_2);
                } else {
                  ESP_LOGW("SD", "Directory %s is exist.", sdpath_2);
                }
                std::string sdpath_3("/2023/05");
                if(!SD.exists(sdpath_3.c_str())) {
                  ESP_LOGW("SD", "Directory %s is not exist.", sdpath_3.c_str());
                  SD.mkdir(sdpath_3.c_str());
                  if(SD.exists(sdpath_3.c_str()))
                    ESP_LOGW("SD", "Created %s", sdpath_3.c_str());
                } else {
                  ESP_LOGW("SD", "Directory %s is exist.", sdpath_3.c_str());
                }
                break;
            }
    - service: tg_test_bot
      variables: 
        data_to_test: int
      then:
        - lambda: |-
            std::string message;
            int msg_length;
            switch(data_to_test) {
              case 1:
                saveToSnapshot(id(em_x_total_counter).state);
                message = generateTelegramBotSummary_1("${energy_source_name} - Test", "${ha_url}", "${grafana_url}");
                ESP_LOGD("Telegram", message.c_str());
                id(tg_bot_publish).execute(
                  message.c_str(),
                  false
                );
                message = generateTelegramBotSummary_2("${energy_source_name} - Test", "${ha_url}", "${grafana_url}");
                ESP_LOGD("Telegram", message.c_str());
                id(tg_bot_publish).execute(
                  message.c_str(),
                  false
                );
                message = generateTelegramBotSummary_3("${energy_source_name} - Test", "${ha_url}", "${grafana_url}");
                ESP_LOGD("Telegram", message.c_str());
                id(tg_bot_publish).execute(
                  message.c_str(),
                  false
                );
                break;
              case 2:
                saveToSnapshot(id(em_x_total_counter).state);
                for(int i = 0; i < PROBLEMS_COUNT; i++) {
                  message = generateProblemMessage("${energy_source_name} - Test", static_cast<Problems>(i), ProblemState::NONE, -1);
                  ESP_LOGD("Telegram", message.c_str());
                  id(tg_bot_publish).execute(
                    message.c_str(),
                    false
                  );
                };
                break;
              case 0:
              default:
                id(tg_bot_publish).execute(
                  "Just a test message",
                  false
                );
                break;
            }
    - service: arm_home
      then:
        - lambda: |-
            id(is_armed) = true;
            sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Case Intrusion detection has been ACTIVATED.");
    - service: disarm
      variables:
        code: string
      then:
        - lambda: |-
            if(code == "$case_pincode") {
              id(is_armed) = false; 
              sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Case Intrusion detection has been DEACTIVATED.");
            } else {
              sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_FAIL, LOG_CATEGORY_NODE, "Case Intrusion detection - invalid pincode provided.");
            }
    - service: logs_clear
      then:
        - lambda: 
            sdcard::deleteArchiveLogs();
            sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Logs archive folder has been cleared.");
    - service: init_snapshot
      variables:
        code: string
      then:
        - lambda: |-
            if(code == "$case_pincode") {
              resetCounters();
              clearSnapshotData(id(rtc_clock).utcnow().timestamp);
              for(int i = 0; i < sizeof(snapData.data); i++) {
                id(snapshot_data)[i] = snapData.data[i];
              };
              ESP_LOGI("Snap data", "Snapshot data has been cleared out.");
              for(int j = 0; j < 64; j++) {
                ESP_LOGD("Snap data", "%02x %02x %02x %02x %02x %02x %02x %02x",
                  id(snapshot_data)[j * 8 + 0],
                  id(snapshot_data)[j * 8 + 1],
                  id(snapshot_data)[j * 8 + 2],
                  id(snapshot_data)[j * 8 + 3],
                  id(snapshot_data)[j * 8 + 4],
                  id(snapshot_data)[j * 8 + 5],
                  id(snapshot_data)[j * 8 + 6],
                  id(snapshot_data)[j * 8 + 7]
                  );
              }
              sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_INFO, LOG_CATEGORY_NODE, "Snapshot data has been cleared.");
            } else {
              sdcard::writeLogfile(id(rtc_clock).utcnow(), LOG_EVENT_TYPE_FAIL, LOG_CATEGORY_NODE, "Authentification Failed - invalid pincode provided.");
            }

mqtt:
  broker: !secret mqtt_broker
  port: 1883
  username: !secret mqtt_usr
  password: !secret mqtt_pwd
  discovery: false
  topic_prefix: !secret mqtt_prefix
  keepalive: 5s

ota:
  password: !secret ota_password

wifi:
  networks:
    - ssid: !secret wifi_name
      password: !secret wifi_pwd
    - ssid: !secret wifi_name_bak
      password: !secret wifi_pwd_bak
  power_save_mode: none
  ap:
    ssid: "VKS Energy Control"
    password: !secret wifi_pwd_ap

time:
  - platform: ds1307
    timezone: Europe/Moscow
    id: rtc_clock
    update_interval: never
    on_time:
      - seconds: 0
        minutes: 59
        hours: 23
        then:
          - script.execute: daily_summary
      - seconds: 0
        minutes: 0
        hours: 9
        then:
          - script.execute: monthly_report
  - platform: homeassistant
    on_time_sync:
      then:
        - ds1307.write_time:

globals:
# variables to store in ESP32 memory

# snapshot data
  - id: snapshot_data
    type: uint8_t[512]
    restore_value: true
# state of case intrusion
  - id: is_armed
    type: boolean
    initial_value: 'true'
    restore_value: true
# state of deep sleep logic
  - id: disable_deep_sleep
    type: boolean
    initial_value: 'true'
    restore_value: true
  - id: system_settings
    type: uint8_t[256]
    restore_value: true

# common data
  - id: is_loaded
    type: boolean
    initial_value: "false"
  - id: is_file_open
    type: boolean
    initial_value: "false"
  - id: card_available
    type: boolean
    initial_value: 'false'
  - id: http_code
    type: int
    initial_value: '-1'

deep_sleep:
  run_duration: 
    gpio_wakeup_reason: 30s
    default: 30s
  sleep_duration: 10min
  id: dsleep 
  esp32_ext1_wakeup:
    pins: 
      - number: GPIO27
        inverted: true
        allow_other_uses: true
    mode: ANY_HIGH
  wakeup_pin_mode: KEEP_AWAKE

output:
  - platform: gpio
    pin:
      number: GPIO32
      mode: 
        output: true
        pulldown: true
    id: power_control_pin
  - platform: gpio
    pin: GPIO25
    id: light_signal_pin

i2c:
  sda: GPIO21
  scl: GPIO22
  id: i2c_bus

uart:
  tx_pin: GPIO17
  rx_pin: GPIO16
  baud_rate: 9600
  stop_bits: 1
  id: modbus_uart_bus

modbus:
  id: modbus_bus
  send_wait_time: 500ms
  uart_id: modbus_uart_bus

modbus_controller:
  - id: main_energy_meter
    modbus_id: modbus_bus
    address: 1
    setup_priority: -10
    offline_skip_updates: 2

sensor:
  - platform: internal_temperature
    name: "ESP32 Internal Temperature"
    entity_category: "diagnostic"
    update_interval: 5s

  - platform: dallas
    name: "House Connection Box Temperature"
    accuracy_decimals: 2
    id: case_temperature_sensor
    unit_of_measurement: °C
    dallas_id: case_temp
    index: 0
    on_value:
      then:
        - lambda: monitorOverheating(x);

  - platform: duty_time
    name: "Energy Uninterrupted"
    sensor: power_input_presence

  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Line Frequency"
    register_type: read
    value_type: FP32
    device_class: frequency
    accuracy_decimals: 3
    state_class: measurement
    unit_of_measurement: Hz
    address: 0x0046
    icon: mdi:sine-wave
    id: line_x_freq

  - platform: total_daily_energy
    name: "Energy Consumed Per Day"
    id: tde_counter
    power_id: em_x_power
    unit_of_measurement: kWh
    state_class: "total_increasing"
    device_class: "energy"
    accuracy_decimals: 3
    filters:
      - multiply: 0.001

  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    id: em_x_total_counter
    name: "Energy Consumed (Counter)"
    register_type: read
    address: 0x0156
    value_type: FP32
    unit_of_measurement: kWh
    state_class: "total_increasing"
    device_class: "energy"
    accuracy_decimals: 3
    icon: mdi:meter-electric-outline

  # Power
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power (Phase A)"
    id: em_a_power
    register_type: read
    address: 0x000C
    value_type: FP32
    unit_of_measurement: W
    device_class: "power"
    state_class: "measurement"
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power (Phase B)"
    id: em_b_power
    register_type: read
    address: 0x000E
    value_type: FP32
    unit_of_measurement: W
    device_class: "power"
    state_class: "measurement"
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power (Phase C)"
    id: em_c_power
    register_type: read
    address: 0x0010
    value_type: FP32
    unit_of_measurement: W
    device_class: "power"
    state_class: "measurement"
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power (Total)"
    id: em_x_power
    register_type: read
    address: 0x0034
    value_type: FP32
    unit_of_measurement: W
    state_class: "measurement"
    device_class: "power"
    accuracy_decimals: 3

  # Voltage
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Voltage (Phase A)"
    id: em_a_voltage
    register_type: read
    address: 0x0000
    value_type: FP32
    unit_of_measurement: V
    device_class: "voltage"
    state_class: "measurement"
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            monitorVoltage(id(em_a_voltage).state, id(em_b_voltage).state, id(em_c_voltage).state);
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Voltage (Phase B)"
    id: em_b_voltage
    register_type: read
    address: 0x0002
    value_type: FP32
    device_class: "voltage"
    state_class: "measurement"
    unit_of_measurement: V
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            monitorVoltage(id(em_a_voltage).state, id(em_b_voltage).state, id(em_c_voltage).state);
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Voltage (Phase C)"
    id: em_c_voltage
    register_type: read
    address: 0x0004
    value_type: FP32
    device_class: "voltage"
    state_class: "measurement"
    unit_of_measurement: V
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            monitorVoltage(id(em_a_voltage).state, id(em_b_voltage).state, id(em_c_voltage).state);
  - platform: template
    id: em_x_voltage
    name: "Average Voltage (L-N)"
    device_class: voltage
    state_class: measurement
    unit_of_measurement: V
    update_interval: 1s
    accuracy_decimals: 3
    icon: mdi:flash-triangle-outline
    lambda: |-
      float a = -1;
      float b = -1;
      float c = -1;
      if(id(em_a_voltage).state >= 0) { a = id(em_a_voltage).state; };
      if(id(em_b_voltage).state >= 0) { b = id(em_b_voltage).state; };
      if(id(em_c_voltage).state >= 0) { c = id(em_c_voltage).state; };
      if((a >= 0) && (b >= 0) && (c >= 0)) {
        return (a + b + c) / 3.0;
      } else {
        return NAN;
      };
  - platform: template
    id: em_x_voltage_min
    name: "Minimal Voltage (L-N)"
    device_class: voltage
    state_class: measurement
    unit_of_measurement: V
    update_interval: 0.5s
    accuracy_decimals: 3
    icon: mdi:flash-triangle-outline
    lambda: |-
      if((id(em_a_voltage).state < id(em_b_voltage).state) &&
         (id(em_a_voltage).state < id(em_c_voltage).state)) {
          return id(em_a_voltage).state;
         } else if((id(em_b_voltage).state < id(em_a_voltage).state) &&
                   (id(em_b_voltage).state < id(em_c_voltage).state)) {
                    return id(em_b_voltage).state;
                   } else {
                    return id(em_c_voltage).state;
                   };
  - platform: template
    id: em_x_voltage_max
    name: "Maximal Voltage (L-N)"
    device_class: voltage
    state_class: measurement
    unit_of_measurement: V
    update_interval: 0.5s
    accuracy_decimals: 3
    icon: mdi:flash-triangle-outline
    lambda: |-
      if((id(em_a_voltage).state > id(em_b_voltage).state) &&
         (id(em_a_voltage).state > id(em_c_voltage).state)) {
          return id(em_a_voltage).state;
         } else if((id(em_b_voltage).state > id(em_a_voltage).state) &&
                   (id(em_b_voltage).state > id(em_c_voltage).state)) {
                    return id(em_b_voltage).state;
                   } else {
                    return id(em_c_voltage).state;
                   };

  # Current
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Current (Phase A)"
    id: em_a_current
    register_type: read
    address: 0x0006
    value_type: FP32
    device_class: "current"
    state_class: "measurement"
    unit_of_measurement: A
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            monitorCurrent(id(em_a_current).state, id(em_b_current).state, id(em_c_current).state);
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Current (Phase B)"
    id: em_b_current
    register_type: read
    address: 0x0008
    value_type: FP32
    device_class: "current"
    state_class: "measurement"
    unit_of_measurement: A
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            monitorCurrent(id(em_a_current).state, id(em_b_current).state, id(em_c_current).state);
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Current (Phase C)"
    id: em_c_current
    register_type: read
    address: 0x00A0
    value_type: FP32
    device_class: "current"
    state_class: "measurement"
    unit_of_measurement: A
    accuracy_decimals: 3
    on_value:
      then:
        - lambda: |-
            monitorCurrent(id(em_a_current).state, id(em_b_current).state, id(em_c_current).state);
  - platform: template
    id: em_x_current_avg
    name: "Average Current Per Phase"
    device_class: current
    state_class: measurement
    unit_of_measurement: A
    update_interval: 1s
    accuracy_decimals: 3
    icon: mdi:flash-triangle
    lambda: |-
      float a = -1;
      float b = -1;
      float c = -1;
      if(id(em_a_current).state >= 0) { a = id(em_a_current).state; };
      if(id(em_b_current).state >= 0) { b = id(em_b_current).state; };
      if(id(em_c_current).state >= 0) { c = id(em_c_current).state; };
      if((a >= 0) && (b >= 0) && (c >= 0)) {
        return (a + b + c) / 3.0;
      } else {
        return NAN;
      };
  - platform: template
    id: em_x_current_sum
    name: "Total Current"
    device_class: current
    state_class: measurement
    unit_of_measurement: A
    accuracy_decimals: 3
    update_interval: 1s
    icon: mdi:flash-triangle
    lambda: |-
      float a = -1;
      float b = -1;
      float c = -1;
      if(id(em_a_current).state >= 0) { a = id(em_a_current).state; };
      if(id(em_b_current).state >= 0) { b = id(em_b_current).state; };
      if(id(em_c_current).state >= 0) { c = id(em_c_current).state; };
      if((a >= 0) && (b >= 0) && (c >= 0)) {
        return (a + b + c);
      } else {
        return NAN;
      };
  - platform: template
    name: "Load Disbalance (Phase A)"
    id: em_a_load_disbalance
    state_class: measurement
    icon: mdi:scale-unbalanced
    unit_of_measurement: "%"
    update_interval: 1s
    accuracy_decimals: 1
    lambda: |-
      auto base = id(em_x_current_avg).state;
      if(base > 0) {
        return id(em_a_current).state / base;
      } else {
        return NAN;
      }
  - platform: template
    name: "Load Disbalance (Phase B)"
    id: em_b_load_disbalance
    icon: mdi:scale-unbalanced
    update_interval: 1s
    state_class: measurement
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      auto base = id(em_x_current_avg).state;
      if(base > 0) {
        return id(em_b_current).state / base;
      } else {
        return NAN;
      }
  - platform: template
    name: "Load Disbalance (Phase C)"
    id: em_c_load_disbalance
    icon: mdi:scale-unbalanced
    update_interval: 1s
    state_class: measurement
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      auto base = id(em_x_current_avg).state;
      if(base > 0) {
        return id(em_c_current).state / base;
      } else {
        return NAN;
      };  
  - platform: template
    name: "Load Disbalance (Max)"
    id: em_x_load_disbalance_max
    icon: mdi:scale-unbalanced
    state_class: measurement
    update_interval: 1s
    unit_of_measurement: "%"
    accuracy_decimals: 1
    lambda: |-
      if(
        (id(em_c_load_disbalance).state >= id(em_a_load_disbalance).state) &&
        (id(em_c_load_disbalance).state >= id(em_b_load_disbalance).state)
      ) {
        return id(em_c_load_disbalance).state;
      } else {
        if(
          (id(em_b_load_disbalance).state >= id(em_a_load_disbalance).state) &&
          (id(em_b_load_disbalance).state >= id(em_c_load_disbalance).state)
        ) {
          return id(em_b_load_disbalance).state;
        } else {
          return id(em_a_load_disbalance).state;
        }
      };

  # Apparent Power
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Apparent Power (Phase A)"
    id: em_a_apparent_power
    register_type: read
    address: 0x0012
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VA
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Apparent Power (Phase B)"
    id: em_b_apparent_power
    register_type: read
    address: 0x0014
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VA
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Apparent Power (Phase C)"
    id: em_c_apparent_power
    register_type: read
    address: 0x0016
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VA
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Apparent Power (Total)"
    id: em_x_apparent_power
    register_type: read
    address: 0x0038
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VA
    accuracy_decimals: 3

  # Reactive Power
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Reactive Power (Phase A)"
    id: em_a_reactive_power
    register_type: read
    address: 0x0018
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VAr
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Reactive Power (Phase B)"
    id: em_b_reactive_power
    register_type: read
    address: 0x001A
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VAr
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Reactive Power (Phase C)"
    id: em_c_reactive_power
    register_type: read
    address: 0x001C
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VAr
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Reactive Power (Total)"
    id: em_x_reactive_power
    register_type: read
    address: 0x003C
    value_type: FP32
    device_class: ""
    state_class: "measurement"
    unit_of_measurement: VAr
    accuracy_decimals: 3

  # Power Factor
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power Factor (Phase A)"
    id: em_a_power_factor
    register_type: read
    address: 0x001E
    value_type: FP32
    device_class: "power_factor"
    state_class: "measurement"
    unit_of_measurement: ""
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power Factor (Phase B)"
    id: em_b_power_factor
    register_type: read
    address: 0x0020
    value_type: FP32
    device_class: "power_factor"
    state_class: "measurement"
    unit_of_measurement: ""
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power Factor (Phase C)"
    id: em_c_power_factor
    register_type: read
    address: 0x0022
    value_type: FP32
    device_class: "power_factor"
    state_class: "measurement"
    unit_of_measurement: ""
    accuracy_decimals: 3
  - platform: modbus_controller
    modbus_controller_id: main_energy_meter
    name: "Power Factor (Total)"
    id: em_x_power_factor
    register_type: read
    address: 0x003E
    value_type: FP32
    device_class: "power_factor"
    state_class: "measurement"
    unit_of_measurement: ""
    accuracy_decimals: 3

  - platform: template
    name: "SD Card Size"
    lambda: |-
      if(id(card_available)) {
        return SD.cardSize() / 1024 / 1024;
      } else {
        return NAN;
      };
    unit_of_measurement: "MB"
    update_interval: 5s
    device_class: data_size
    entity_category: DIAGNOSTIC
  - platform: template
    name: "SD Volume Total Size"
    lambda: |-
      if(id(card_available)) {
        return SD.totalBytes() / 1024 / 1024;
      } else {
        return NAN;
      };
    unit_of_measurement: "MB"
    update_interval: 5s
    device_class: data_size
    entity_category: DIAGNOSTIC
  - platform: template
    name: "SD Volume Free Size"
    lambda: |-
      if(id(card_available)) {
        return (SD.totalBytes() - SD.usedBytes()) / 1024 / 1024;
      } else {
        return NAN;
      };
    unit_of_measurement: "MB"
    update_interval: 5s
    device_class: data_size
    entity_category: DIAGNOSTIC
  - platform: template
    name: "Frequency Warning Level (±Hz)"
    lambda: return settings::settingsData.content.settings.frequencyShiftWarningLevel;
    id: config_freq_warning_level
    unit_of_measurement: "Hz"
    update_interval: 15s
    entity_category: DIAGNOSTIC
  - platform: template
    name: "Frequency Failure Level (±Hz)"
    lambda: return settings::settingsData.content.settings.frequencyShiftFailureLevel;
    id: config_freq_failure_level
    unit_of_measurement: "Hz"
    update_interval: 15s
    entity_category: DIAGNOSTIC

text_sensor:
  - platform: template
    name: "Load Balance"
    icon: mdi:scale-balance
    id: em_x_load_balance_state
    update_interval: 1s
    lambda: |-
      if(getProblem(Problems::PHASE_SHIFT) == ProblemState::FAILURE) {
        return {"CRITICAL"};
      } else if (getProblem(Problems::PHASE_SHIFT) == ProblemState::WARNING) {
        return {"BAD"};
      } else if (id(em_x_load_disbalance_max).state > 0.0) {
        return {"GOOD"};
      } else {
        return {"PERFECT"};
      };
  - platform: template
    name: "SD Card Type"
    entity_category: DIAGNOSTIC
    update_interval: 1s
    lambda: |-
      if(id(card_available)) {
        switch (SD.cardType())
        {
          case CARD_NONE:
            return {"NONE"};
          case CARD_MMC:
            return {"MMC"};
          case CARD_SD:
            return {"SDSC"};
          case CARD_SDHC:
            return {"SDHC"};  
          default:
            return {"UNKNOWN"};
        }      
      } else {
        return {"NONE"};
      };

binary_sensor:
  - platform: template
    name: "Powered On?"
    device_class: connectivity
    id: power_input_presence
    icon: mdi:transmission-tower-import
    lambda: |-
      return !id(main_energy_meter).get_module_offline();
    on_state:
      then:
        - lambda: |-
            monitorPowerFailure(x);
  - platform: gpio
    pin: GPIO35
    name: "Power Protection Failure"
    device_class: problem
    icon: mdi:transmission-tower-off
    id: power_input_protection_failure
    filters:
      - delayed_on_off: 0.5s
    on_state:
      then:
        - lambda: |-
            monitorBreaker(x);
  - platform: gpio
    pin: 
      number: GPIO27
      inverted: true
      allow_other_uses: true
    name: "UPS AC State"
    id: ups_ac_state
    icon: mdi:power-plug
    filters:
      - delayed_on_off: 0.5s
    on_state:
      then:
        - lambda: |-
            monitorACLineFailure(x);
  - platform: gpio
    pin: 
      number: GPIO33
      inverted: true
    device_class: battery
    name: "UPS Battery State"
    id: ups_battery_state
    icon: mdi:battery-alert-variant-outline
    filters:
      - delayed_on_off: 0.5s
    on_state:
      then:
        - lambda: |-
            monitorBatteryFailure(x);
  - platform: gpio
    pin: 
      number: GPIO34
      inverted: true
    name: "Case State"
    id: case_open
    icon: mdi:shield-lock-open
    device_class: door
    filters:
      - delayed_on_off: 0.5s
    on_state:
      then:
        - lambda: |-
            monitorCaseIntrusion(x && id(is_armed));

number:
  - platform: template
    name: "Undervoltage Warning Level"
    id: conf_undervoltage_warn_lvl
    min_value: $voltage_min_bound
    max_value: $voltage_normal
    step: 0.5
    unit_of_measurement: "V"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.undervoltageWarningLevel;
    set_action:
      then:
        - lambda: |-
            if(x <= id(conf_undervoltage_fail_lvl).state) {
              settings::settingsData.content.settings.undervoltageWarningLevel = 
                    id(conf_undervoltage_fail_lvl).state + 1.0;
            } else {
              settings::settingsData.content.settings.undervoltageWarningLevel = x;
            }; 
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Undervoltage Failure Level"
    id: conf_undervoltage_fail_lvl
    min_value: $voltage_min_bound
    max_value: $voltage_normal
    step: 0.5
    unit_of_measurement: "V"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.undervoltageFailureLevel;
    set_action:
      then:
        - lambda: |-
            if(x >= id(conf_undervoltage_warn_lvl).state) {
              settings::settingsData.content.settings.undervoltageFailureLevel = 
                id(conf_undervoltage_warn_lvl).state - 1.0;
            } else {
              settings::settingsData.content.settings.undervoltageFailureLevel = x;
            };
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Overvoltage Warning Level"
    id: conf_overvoltage_warn_lvl
    min_value: $voltage_normal
    max_value: $voltage_max_bound
    step: 0.5
    unit_of_measurement: "V"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.overvoltageWarningLevel;
    set_action:
      then:
        - lambda: |-
            if(x >= id(conf_overvoltage_fail_lvl).state) {
              settings::settingsData.content.settings.overvoltageWarningLevel = 
                id(conf_overvoltage_fail_lvl).state - 1.0;
            } else {
              settings::settingsData.content.settings.overvoltageWarningLevel = x;
            }; 
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Overvoltage Failure Level"
    id: conf_overvoltage_fail_lvl
    min_value: $voltage_normal
    max_value: $voltage_max_bound
    step: 0.5
    unit_of_measurement: "V"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.overvoltageFailureLevel;
    set_action:
      then:
        - lambda: |-
            if(x <= id(conf_overvoltage_warn_lvl).state) {
              settings::settingsData.content.settings.overvoltageFailureLevel = 
                id(conf_overvoltage_warn_lvl).state + 1.0;
            } else {
              settings::settingsData.content.settings.overvoltageFailureLevel = x;
            };
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Phase Disbalance Warning Level"
    id: phase_shift_warn_lvl
    min_value: 0.5
    max_value: 10.0
    step: 0.5
    unit_of_measurement: "%"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.phaseShiftWarningLevel;
    set_action:
      then:
        - lambda: |-
            settings::settingsData.content.settings.phaseShiftWarningLevel = x; 
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Phase Disbalance Critical Level"
    id: phase_shift_fail_lvl
    min_value: 10.5
    max_value: 100.0
    step: 0.5
    unit_of_measurement: "%"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.phaseShiftFailureLevel;
    set_action:
      then:
        - lambda: |-
            settings::settingsData.content.settings.phaseShiftFailureLevel = x; 
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Overload Warning Level"
    id: overload_warn_lvl
    min_value: 16
    max_value: $supported_load_level
    step: 0.5
    unit_of_measurement: "A"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.overloadWarningLevel;
    set_action:
      then:
        - lambda: |-
            settings::settingsData.content.settings.overloadWarningLevel = x; 
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Overload Critical Level"
    id: overload_fail_lvl
    min_value: $supported_load_level
    max_value: 100
    step: 0.5
    unit_of_measurement: "A"
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.overloadFailureLevel;
    set_action:
      then:
        - lambda: |-
            settings::settingsData.content.settings.overloadFailureLevel = x; 
            if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Monthly Report Day"
    id: monthly_report_day
    min_value: 1
    max_value: 31
    step: 1
    entity_category: CONFIG
    lambda: |-
      return settings::settingsData.content.settings.monthlyReportDay;
    set_action:
      then:
        - lambda: |-
            settings::settingsData.content.settings.monthlyReportDay =
              static_cast<int>(x);
            if(id(is_loaded)) { settings::writeSettings(); };

light:
  - platform: binary
    output: light_signal_pin
    id: light_signal
    effects:
      - strobe:
          name: slow_warn
          colors:
            - state: true
              duration: 2s
            - state: false
              duration: 2s
      - strobe:
          name: alert
          colors:
            - state: true
              duration: 250ms
            - state: false
              duration: 100ms
            - state: true
              duration: 250ms
            - state: false
              duration: 100ms
            - state: true
              duration: 250ms
            - state: false
              duration: 500ms
            - state: true
              duration: 250ms
            - state: false
              duration: 500ms
      - strobe:
          name: warning
          colors:
            - state: true
              duration: 1s
            - state: false
              duration: 1s
            - state: true
              duration: 1s
            - state: false
              duration: 2s

select:
  - platform: template
    name: "Gateway Control"
    id: gateway_control_behavior
    icon: mdi:gate-open
    options:
      - Follow Node Power
      - Follow Home Power
      - Disabled
    entity_category: "CONFIG"
    lambda: |-
      return id(gateway_control_behavior).at(settings::settingsData.content.settings.gatewayNodePowerPolicy);
    set_action:
      - lambda: |-
          auto aidx = id(gateway_control_behavior).index_of(x);
          ESP_LOGI("Gateway Control", "Active option index is %d.", aidx.has_value() ? aidx.value() : -1);
          if(aidx.has_value())
            settings::settingsData.content.settings.gatewayNodePowerPolicy
              = aidx.value();
          else
            settings::settingsData.content.settings.gatewayNodePowerPolicy
              = 0;
          if(id(is_loaded)) { settings::writeSettings(); };
          switch(settings::settingsData.content.settings.gatewayNodePowerPolicy) {
            case 0: // Child node will be disabled when this Node UPS is offline.
              if(getProblem(Problems::AC_LINE) != ProblemState::NONE) {
                id(power_control_pin).turn_off();
                ESP_LOGI("Gateway Control", "Nested node is switched OFF (Node UPS is offline).");
              } else {
                id(power_control_pin).turn_on();
                ESP_LOGI("Gateway Control", "Nested node is switched ON (Node UPS is online).");
              };
              break;
            case 1: // Child node will be disabled when whole home is off the grid.
              if(getProblem(Problems::GENERIC_POWER_FAILURE) != ProblemState::NONE) {
                id(power_control_pin).turn_off();
                ESP_LOGI("Gateway Control", "Nested node is switched OFF (Generic Power Failure).");
              } else {
                id(power_control_pin).turn_on();
                ESP_LOGI("Gateway Control", "Nested node is switched ON (Generic Power Failure fixed).");
              };
              break;
            case 2: // Child node will be always disabled
            default:
              id(power_control_pin).turn_off();
              ESP_LOGI("Gateway Control", "Nested node is switched OFF (Manual Control).");
              break;
          }

switch:
  - platform: template
    name: "Generate Summary"
    id: summary_enabled
    icon: mdi:file-chart
    entity_category: "CONFIG"
    lambda: |-
      return settings::settingsData.content.settings.publishSummary;
    turn_on_action:
      - lambda: |- 
          settings::settingsData.content.settings.publishSummary = true;
          if(id(is_loaded)) { settings::writeSettings(); };
    turn_off_action:
      - lambda: |- 
          settings::settingsData.content.settings.publishSummary = false;
          if(id(is_loaded)) { settings::writeSettings(); };
  - platform: template
    name: "Prevent Deep Sleep mode"
    entity_category: "CONFIG"
    icon: mdi:sleep-off
    lambda: return id(disable_deep_sleep);
    turn_on_action:
      - if:
          condition:
            lambda: return id(is_loaded);
          then:
            - lambda: |- 
                id(disable_deep_sleep) = true;
            - deep_sleep.prevent: dsleep
    turn_off_action:
      - if:
          condition:
            lambda: return id(is_loaded);
          then:
            - lambda: |- 
                id(disable_deep_sleep) = false;
            - deep_sleep.allow: dsleep


button:
  - platform: template
    name: "Factory Reset Node"
    icon: mdi:reload-alert
    on_press:
      - lambda: settings::resetSettings(true);
    entity_category: "CONFIG"
  - platform: restart
    name: "Reboot Node"
    entity_category: "CONFIG"


interval:
  - interval: 1s
    then:
      - script.execute:
          id: power_monitor
  - interval: 1s
    then:
      - lambda: |-
          //Monitor card available.
          if(!id(card_available)) {
            ESP_LOGD("SD", "Trying to mount card...");
            id(card_available) = SD.begin(5);
            if(!id(card_available)) {
              ESP_LOGW("SD", "Unable to mount SD card.");
              return;
            };
          } else {
            id(card_available) = (SD.cardType() != CARD_NONE && SD.cardType() != CARD_UNKNOWN);
          };

http_request:
  useragent: esp32/device
  timeout: 10s

script:
  - id: save_snapshot
    mode: single
    then:
      - lambda: |-
          saveToSnapshot(id(em_x_total_counter).state);
          for(int i = 0; i < sizeof(snapData.data); i++) {
            id(snapshot_data)[i] = snapData.data[i];
          };

  - id: load_snapshot
    mode: single
    then:
      - lambda: |-
          for(int i = 0; i < sizeof(snapData.data); i++) {
            snapData.data[i] = id(snapshot_data)[i];
          };
          loadFromSnapshot(id(em_x_total_counter).state);

  - id: tg_bot_publish
    mode: queued
    parameters:
      message: string
      silent: boolean
    then:
      - lambda: |-
          id(http_code) = -1;
          id(tg_bot_publish_int)->execute(message.c_str(), silent);
      - wait_until:
          not:
            script.is_running: tg_bot_publish_int
      - lambda: |-
          int http_result = id(http_code);
          if((http_result < 200) || (http_result >= 400)) {
            ESP_LOGE("HTTP", "Unable to send request to TG API. Code: %d. Trying to send it once more time...", http_result);
            id(tg_bot_publish_int)->execute(message.c_str(), silent);
          };
      
  - id: tg_bot_publish_int
    mode: single
    parameters:
      message: string
      silent: boolean
    then:
      - http_request.post:
          url: "https://api.telegram.org/bot${tg_bot_token}/sendMessage"
          headers:
            Content-Type: application/json
          json:
            chat_id: ${tg_chat_id}
            text: !lambda return message.c_str();
            parse_mode: "HTML"
            disable_notification: !lambda if(silent) { return "true"; } else { return "false"; };
          verify_ssl: false
          on_response:
            - lambda: id(http_code) = status_code;

  - id: process_problem
    mode: queued
    parameters:
      problem_type: int
      problem_state: int
    then:
      - mqtt.publish:
          payload: !lambda |-
            switch(problem_state) {
              case ProblemState::NONE:
                return "0";
              case ProblemState::WARNING:
                return "1";
              case ProblemState::FAILURE:
              default:
                return "2";
            }
          topic: !lambda |-
            char buffer[128];
            snprintf(buffer, sizeof(buffer),
              "Infra/Energy/Sources/${energy_source_name}/Problems/%s",
              PROBLEMS_KEYS.at(static_cast<Problems>(problem_type))
            );
            return std::string(buffer).c_str();
      - lambda: |-
          if(!id(is_loaded))
            return;
          saveToSnapshot(id(em_x_total_counter).state);
          for(int i = 0; i < sizeof(snapData.data); i++) {
            id(snapshot_data)[i] = snapData.data[i];
          };
          double value = NAN;
          switch(problem_type) {
            case Problems::UNDERVOLTAGE:
              value = id(em_x_voltage_min).state;
              break;
            case Problems::OVERVOLTAGE:
              value = id(em_x_voltage_max).state;
              break;
            case Problems::OVERLOAD:
              value = id(em_x_current_sum).state;
              break;
            case Problems::FREQUENCY_SHIFT:
              value = abs(id(line_x_freq).state - FREQUENCY);
              break;
            case Problems::OVERHEAT:
              value = id(case_temperature_sensor).state;
            case Problems::PHASE_SHIFT:
              value = id(em_x_load_disbalance_max).state;
              break;
            case Problems::GENERIC_POWER_FAILURE:
              if(problem_state != ProblemState::NONE) {
                id(power_fail).execute();
              } else {
                id(power_restore).execute();
              };
              break;
            case Problems::AC_LINE:
              if(problem_state != ProblemState::NONE) {
                id(ups_offline).execute();
              } else {
                id(ups_online).execute();
              };
              break;
            default:
              break;
          };
          id(tg_bot_publish).execute(
            generateProblemMessage("${energy_source_name}",
              static_cast<Problems>(problem_type),
              static_cast<ProblemState>(problem_state),
              value),
            false
          );
      - lambda: |-
          switch(settings::settingsData.content.settings.gatewayNodePowerPolicy) {
            case 0: // Child node will be disabled when this Node UPS is offline.
              if((problem_type == Problems::AC_LINE) &&
                   (problem_state != ProblemState::NONE)) {
                id(power_control_pin).turn_off();
                ESP_LOGI("Gateway Control", "Nested node is switched OFF (Node UPS is offline).");
              } else {
                id(power_control_pin).turn_on();
                ESP_LOGI("Gateway Control", "Nested node is switched ON (Node UPS is online).");
              };
              break;
            case 1: // Child node will be disabled when whole home is off the grid.
              if((problem_type == Problems::GENERIC_POWER_FAILURE) &&
                   (problem_state != ProblemState::NONE)) {
                id(power_control_pin).turn_off();
                ESP_LOGI("Gateway Control", "Nested node is switched OFF (Generic Power Failure).");
              } else {
                id(power_control_pin).turn_on();
                ESP_LOGI("Gateway Control", "Nested node is switched ON (Generic Power Failure fixed).");
              };
              break;
            case 2: // Child node will be always disabled
            default:
              id(power_control_pin).turn_off();
              ESP_LOGI("Gateway Control", "Nested node is switched OFF (Manual Control).");
              break;
          }
      - lambda: |-
          switch(problem_state) {
            case ProblemState::NONE:
              sdcard::writeLogfile(
                  id(rtc_clock).utcnow(),
                    LOG_EVENT_TYPE_INFO,
                    PROBLEMS_NAMES.at(static_cast<Problems>(problem_type)),
                    "State has been normalized.");
              break;
            case ProblemState::WARNING:
              sdcard::writeLogfile(
                  id(rtc_clock).utcnow(),
                    LOG_EVENT_TYPE_WARN,
                    PROBLEMS_NAMES.at(static_cast<Problems>(problem_type)),
                    "Reached a cautious state.");
              break;
            case ProblemState::FAILURE:
            default:
              sdcard::writeLogfile(
                  id(rtc_clock).utcnow(),
                    LOG_EVENT_TYPE_FAIL,
                    PROBLEMS_NAMES.at(static_cast<Problems>(problem_type)),
                    "Failure has been registered.");
              break;
          };

  - id: daily_summary
    mode: single
    then:
      - wait_until:
          condition:
            lambda: return id(rtc_clock).utcnow().is_valid() && sdcard::can_claim();
          timeout: 5s
      - lambda: |-
          auto ts = id(rtc_clock).now();
          auto current_counter = id(em_x_total_counter).state;
          if(!ts.is_valid()) {
            ESP_LOGE(TAG_SNAPSHOT, "Unable to write down summary data. No time defined.");
            return;
          };
          saveToSnapshot(current_counter); //Using current day data in snapshot.     
          if(!writeDailyLog(ts)) {
            ESP_LOGE(TAG_SNAPSHOT, "Unable to write down summary data. IO error.");
          };
          if(settings::settingsData.content.settings.publishSummary) {
            ESP_LOGI(TAG_SNAPSHOT, "Trying to publish summary to Telegram bot.");
            id(tg_bot_publish).execute(
              generateTelegramBotSummary_1("${energy_source_name}", "${ha_url}", "${grafana_url}"),
              true);
            id(tg_bot_publish).execute(
              generateTelegramBotSummary_2("${energy_source_name}", "${ha_url}", "${grafana_url}", id(rtc_clock).utcnow().timestamp),
              true);
            id(tg_bot_publish).execute(
              generateTelegramBotSummary_3("${energy_source_name}", "${ha_url}", "${grafana_url}"),
              true);
          };
          commitDailyData(current_counter, id(rtc_clock).utcnow().timestamp); //Resetting snapshot data to brand new day.
          resetCounters(); // Resetting problem counters.
          saveToSnapshot(current_counter); //Using brand new day data in snapshot.
          for(int i = 0; i < sizeof(snapData.data); i++) {
            id(snapshot_data)[i] = snapData.data[i];
          };

  - id: ups_online
    mode: single
    then:
      - deep_sleep.prevent: dsleep
      - script.execute: 
          id: load_snapshot
  
  - id: ups_offline
    mode: single
    then:
      - script.execute:
          id: save_snapshot
      - delay: 2s
      - if:
          condition:
            - lambda: return !id(disable_deep_sleep);
          then:
            - deep_sleep.allow: dsleep

  - id: power_restore
    mode: single
    then: 
      - mqtt.publish:
          topic: Infra/Energy/Sources/${energy_source_name}/Active
          payload: "true"

  - id: power_fail
    mode: single
    then:
      - mqtt.publish:
          topic: Infra/Energy/Sources/${energy_source_name}/Active
          payload: "false"

  - id: power_monitor
    mode: queued
    then:
      - mqtt.publish_json:
          topic: Infra/Energy/Sources/${energy_source_name}/Monitor
          qos: 2
          retain: true
          payload: |-
            root["frequency"] = id(line_x_freq).state;
            
            auto power_data = root.createNestedObject("power");

            auto active_power = power_data.createNestedObject("active");
            auto apparent_power = power_data.createNestedObject("apparent");
            auto reactive_power = power_data.createNestedObject("reactive");

            active_power["A"] = id(em_a_power).state;
            active_power["B"] = id(em_b_power).state;
            active_power["C"] = id(em_c_power).state;
            active_power["total"] = id(em_x_power).state;

            apparent_power["A"] = id(em_a_apparent_power).state;
            apparent_power["B"] = id(em_b_apparent_power).state;
            apparent_power["C"] = id(em_c_apparent_power).state;
            apparent_power["total"] = id(em_x_apparent_power).state;

            reactive_power["A"] = id(em_a_reactive_power).state;
            reactive_power["B"] = id(em_b_reactive_power).state;
            reactive_power["C"] = id(em_c_reactive_power).state;
            reactive_power["total"] = id(em_x_reactive_power).state;

            auto voltage = root.createNestedObject("voltage");
            voltage["A"] = id(em_a_voltage).state;
            voltage["B"] = id(em_b_voltage).state;
            voltage["C"] = id(em_c_voltage).state;
            voltage["average"] = id(em_x_voltage).state;

            auto current = root.createNestedObject("current");
            current["A"] = id(em_a_current).state;
            current["B"] = id(em_b_current).state;
            current["C"] = id(em_c_current).state;
            current["total"] = id(em_x_current_sum).state;
            current["average"] = id(em_x_current_avg).state;
      - lambda: |-
          switch(settings::settingsData.content.settings.gatewayNodePowerPolicy) {
            case 0: // Child node will be disabled when this Node UPS is offline.
              if(getProblem(Problems::AC_LINE) != ProblemState::NONE) {
                id(power_control_pin).turn_off();
                ESP_LOGD("Gateway Control", "Nested node is switched OFF (Node UPS is offline).");
              } else {
                id(power_control_pin).turn_on();
                ESP_LOGD("Gateway Control", "Nested node is switched ON (Node UPS is online).");
              };
              break;
            case 1: // Child node will be disabled when whole home is off the grid.
              if(getProblem(Problems::GENERIC_POWER_FAILURE) != ProblemState::NONE) {
                id(power_control_pin).turn_off();
                ESP_LOGD("Gateway Control", "Nested node is switched OFF (Generic Power Failure).");
              } else {
                id(power_control_pin).turn_on();
                ESP_LOGD("Gateway Control", "Nested node is switched ON (Generic Power Failure fixed).");
              };
              break;
            case 2: // Child node will be always disabled
            default:
              id(power_control_pin).turn_off();
              ESP_LOGD("Gateway Control", "Nested node is switched OFF (Manual Control).");
              break;
          }

  - id: monthly_report
    then:
      - lambda: |-
          auto ts = id(rtc_clock).now();

          if(!ts.is_valid()) {
            ESP_LOGE("TIME", "Unable to create report on undefined time.");
            return;
          };

          if((ts.day_of_month != id(monthly_report_day).state) && (id(monthly_report_day).state <= 28)) {
            return; //Nothing to do. Not a report day.
          };

          if((ts.day_of_month < id(monthly_report_day).state) && (id(monthly_report_day).state > 28)) {
            //Check for months that ends before report day.
            auto current_month = ts.month;
            ts.increment_day();
            if(ts.month == current_month) {
              return; //Not the last day in the current month. No need to report.
            }
          };

          char buffer[256];
          snprintf(buffer, sizeof(buffer), TG_POWER_CONSUMPTION_PER_MONTH,
            "${energy_source_name}", id(em_x_total_counter).state);
          id(tg_bot_publish).execute(
            std::string(buffer).c_str(),
            false
          );

